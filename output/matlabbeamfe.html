<!DOCTYPE html>
<html lang="en">
<head>
  <link rel='stylesheet' type='text/css' href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic'>
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
  <link rel="stylesheet" type="text/css" href="//amit.visrolia.net/theme/pygments/monokai.min.css">
  <link rel="stylesheet" type="text/css" href="//amit.visrolia.net/theme/stylesheet/tipuesearch.css">
  <link rel="stylesheet" type="text/css" href="//amit.visrolia.net/theme/stylesheet/style.min.css">
  <link rel="stylesheet" type="text/css" href="//amit.visrolia.net/theme/stylesheet/style.local.css">
  <link rel='manifest' href='//amit.visrolia.net/manifest.json'>

  <link href="//amit.visrolia.net/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Amit's notes Atom">
  <link rel="shortcut icon" href="//amit.visrolia.net/favicon.ico" type="image/png">
  <link rel="icon" href="//amit.visrolia.net/favicon.ico" type="image/png">

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

  <!-- Chrome, Firefox OS and Opera -->
  <meta name="theme-color" content="#333333">
  <!-- Windows Phone -->
  <meta name="msapplication-navbutton-color" content="#333333">
  <!-- iOS Safari -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="author" content="Amit" />
<meta name="description" content="Beam Finite Element Analysis Here, we’re going to take a brief overview of the steps required in producing a Finite Element (FE) programme for beam analysis. Not all the answers are in these notes! There should be enough hints to produce a 2D FE code. If we can produce …" />
<meta name="keywords" content="matlab, code, teaching, bath">
<meta property="og:site_name" content="Amit's notes"/>
<meta property="og:title" content="Introduction to Matlab: lecture 2"/>
<meta property="og:description" content="Beam Finite Element Analysis Here, we’re going to take a brief overview of the steps required in producing a Finite Element (FE) programme for beam analysis. Not all the answers are in these notes! There should be enough hints to produce a 2D FE code. If we can produce …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="//amit.visrolia.net/matlabbeamfe.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2011-11-01 00:00:00+00:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="//amit.visrolia.net/author/amit.html">
<meta property="article:section" content="Notes"/>
<meta property="article:tag" content="matlab"/>
<meta property="article:tag" content="code"/>
<meta property="article:tag" content="teaching"/>
<meta property="article:tag" content="bath"/>
<meta property="og:image" content="">

  <title>Amit's notes &ndash; Introduction to Matlab: lecture 2</title>
</head>
<body>
  <aside>
    <div>
      <a href="//amit.visrolia.net/">
        <img src="//amit.visrolia.net/theme/img/profile.png" alt="Amit" title="Amit">
      </a>
      <h1><a href="//amit.visrolia.net/">Amit</a></h1>

      <!--<p>Notes, links, and pictures</p>-->
      
      <p><a href="//amit.visrolia.net/category/notes.html" alt="Notes">Notes</a>, <a href="//amit.visrolia.net/category/links.html" alt="Links">links</a>, and <a href="//amit.visrolia.net/category/pictures.html" alt="Pictures">pictures</a></p>

      <nav>
        <ul class="list">
          <li><a href="//amit.visrolia.net/pages/amit.html#amit">About&nbsp;me</a></li>
          <li><a href="//amit.visrolia.net/pages/credits.html#credits">Credits</a></li>

        </ul>
      </nav>

      <form id="tipue_search_form" action="//amit.visrolia.net/search.html" onsubmit="return (this.elements['q'].value.length > 0)">
        <input id="tipue_search_input" name="q" type="search" autocomplete="off" placeholder="Search" required>
      </form>
      
      <ul class="social">
        <li><a class="sc-xlinkedin" href="https://uk.linkedin.com/in/amitvisrolia" target="_blank"><i class="fa fa-xlinkedin"></i></a></li>
        <li><a class="sc-github" href="https://github.com/amitviz" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-rss" href="/feeds/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    
      
    </div>
  </aside>
  <main>

<article>
  <header>
    <h1 id="matlabbeamfe">Introduction to Matlab: lecture&nbsp;2</h1>
    <p>
          Posted on November 01, 2011 in <a href="//amit.visrolia.net/category/notes.html">Notes</a>


    </p>
  </header>
  <div>
    <h1>Beam Finite Element&nbsp;Analysis</h1>
<p>Here, we&#8217;re going to take a brief overview of the steps required in producing a Finite Element (<span class="caps">FE</span>) programme for beam&nbsp;analysis.</p>
<ul>
<li><strong>Not all the answers are in these&nbsp;notes!</strong></li>
<li>There should be enough hints to produce a 2D <span class="caps">FE</span>&nbsp;code.</li>
<li>If we can produce a 2D code, extending it to 3D should be&nbsp;trivial.</li>
</ul>
<h2>Finite element&nbsp;analysis</h2>
<h3>Parts of an <span class="caps">FE</span>&nbsp;program</h3>
<p><img alt="Parts of an FEA program" src="/images/fea2.png"></p>
<ul>
<li>Problem definition<ul>
<li>component&nbsp;shape</li>
<li>materials</li>
<li>loads</li>
</ul>
</li>
<li>Preprocessor<ul>
<li>digital representation: the&nbsp;&#8216;geometry&#8217;</li>
<li>mathematical representation of material&nbsp;behaviour</li>
<li>discretization:&nbsp;&#8216;meshing&#8217;</li>
</ul>
</li>
<li>Solver<ul>
<li>form element stiffness&nbsp;matrices</li>
<li>assemble global&nbsp;matrices</li>
<li>apply boundary&nbsp;conditions</li>
<li>solve for nodal&nbsp;unknowns</li>
</ul>
</li>
<li>Postprocessor<ul>
<li>calculate derived quantities, <em>e.g.</em> strains, stresses, thermal&nbsp;gradients</li>
<li>plotting and visualization&nbsp;tools</li>
</ul>
</li>
<li>Useful output<ul>
<li>does my component&nbsp;work?</li>
</ul>
</li>
</ul>
<h3>Problem&nbsp;definition</h3>
<p><strong>Truss</strong> or <strong>beam</strong>&nbsp;elements</p>
<ul>
<li>defined by length <span class="math">\(L\)</span>, area <span class="math">\(A\)</span>, modulus <span class="math">\(E\)</span></li>
<li>pin-jointed</li>
<li>uniform&nbsp;strain</li>
<li>fixed locations, sliding joints, free&nbsp;joints</li>
</ul>
<p>Solve for displacements <span class="math">\(\mathbf{u}\)</span> (vector quantity), strains and&nbsp;stresses.</p>
<h3>Pre-processor</h3>
<p>The problem definition already represents a suitable mesh: &#8216;elements&#8217; correspond to beams, &#8216;nodes&#8217; correspond to&nbsp;joints.</p>
<ul>
<li>a <strong>node</strong> is defined by its&nbsp;coordinates</li>
<li>an <strong>element</strong> is defined by the nodes it&nbsp;connects</li>
</ul>
<p>We can input these data directly in the form of a list (of course, <span class="caps">MATLAB</span> calls this a &#8216;matrix&#8217;). It&#8217;s also useful to input the moduli and areas: also as a list, since they might not be the same for all&nbsp;beams.</p>
<p><img alt="2D beams" src="/images/2dbeams_annotated.png"></p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">nodal_coordinates</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span>   <span class="c">% 1 row per node</span>
<span class="n">element_nodes</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">];</span>       <span class="c">% 1 row/element</span>
<span class="n">element_area</span> <span class="p">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">;</span> <span class="mi">6</span><span class="p">;</span> <span class="mi">6</span><span class="p">]</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">;</span>        <span class="c">% 1 row/element </span>
<span class="n">element_modulus</span> <span class="p">=</span> <span class="p">[</span><span class="mi">210</span><span class="p">;</span> <span class="mi">210</span><span class="p">;</span> <span class="mi">210</span><span class="p">]</span><span class="o">*</span><span class="mf">1e9</span><span class="p">;</span>
<span class="c">% note that for the area and modulus, I&#39;ve used a short</span>
<span class="c">%   hand form by multiplying a vector by a scalar</span>
<span class="n">nodal_forces</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mf">1000e3</span> <span class="mi">0</span><span class="p">];</span> <span class="c">% each node has</span>
                                    <span class="c">%   a vector force</span>
</pre></div>
</td></tr></table>

<p>Remember: unit&nbsp;consistency!</p>
<h3>Information about the&nbsp;model</h3>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span> <span class="n">nodal_coordinates</span>         <span class="c">% the full nodal coordinates list</span>
<span class="n">nodal_coordinates</span> <span class="p">=</span>
    <span class="mi">0</span>     <span class="mi">0</span>
    <span class="mi">1</span>     <span class="mi">0</span>
    <span class="mi">1</span>     <span class="mi">1</span>
<span class="o">&gt;&gt;</span> <span class="n">element_nodes</span>             <span class="c">% the full element nodes list</span>
<span class="n">element_nodes</span> <span class="p">=</span>
    <span class="mi">1</span>     <span class="mi">2</span>
    <span class="mi">2</span>     <span class="mi">3</span>
    <span class="mi">1</span>     <span class="mi">3</span>
<span class="o">&gt;&gt;</span> <span class="c">% coordinates of node 2</span>
<span class="o">&gt;&gt;</span> <span class="n">nodal_coordinates</span><span class="p">(</span><span class="mi">2</span><span class="p">,:)</span>    <span class="c">% from nodal_coordinates, pick row 2, all columns (x and y)</span>
<span class="nb">ans</span> <span class="p">=</span>
    <span class="mi">1</span>     <span class="mi">0</span>
<span class="o">&gt;&gt;</span> <span class="c">% nodes of element 2</span>
<span class="o">&gt;&gt;</span> <span class="n">element_nodes</span><span class="p">(</span><span class="mi">2</span><span class="p">,:)</span>        <span class="c">% from element_nodes, pick row 2, all columns (all nodes)</span>
<span class="nb">ans</span> <span class="p">=</span>
    <span class="mi">2</span>     <span class="mi">3</span>
<span class="o">&gt;&gt;</span> <span class="c">% coordinates of element 2</span>
<span class="o">&gt;&gt;</span> <span class="n">nodal_coordinates</span><span class="p">(</span><span class="n">element_nodes</span><span class="p">(</span><span class="mi">2</span><span class="p">,:),:)</span> <span class="c">% find the coordinates of the nodes of element 2</span>
<span class="nb">ans</span> <span class="p">=</span>
    <span class="mi">1</span>     <span class="mi">0</span>
    <span class="mi">1</span>     <span class="mi">1</span>
<span class="o">&gt;&gt;</span> <span class="n">element_area</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>           <span class="c">% the cross-sectional area of element 2. Since this is a vector</span>
<span class="nb">ans</span> <span class="p">=</span>                        <span class="c">%   we can be lazy and omit the other index (since it will</span>
    <span class="mf">0.0006</span>                   <span class="c">%   always be 1)</span>
<span class="o">&gt;&gt;</span> <span class="n">element_modulus</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>        <span class="c">% the modulus of element 2</span>
<span class="nb">ans</span> <span class="p">=</span>
<span class="mf">2.1000e+11</span>
</pre></div>


<h3>What about the element&nbsp;lengths?</h3>
<p>The length of the element is also a factor. However, we don&#8217;t need to input this information, since is is implicit in the nodal coordinates and element definitions. We could write a function to calculate it for&nbsp;us:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>[element_length] <span class="p">=</span><span class="w"> </span><span class="nf">calculate_length</span><span class="p">(</span>arguments<span class="p">)</span><span class="w"></span>
<span class="c">% A function to calculate the length(s) of an element/ all the elements</span>

<span class="c">% define the function here!</span>
<span class="k">return</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>The function will implement (for the 2D&nbsp;case):
</p>
<div class="math">\begin{align}
L = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\end{align}</div>
<p><img alt="Element length calculation" src="/images/elementlength_calc.png"></p>
<p>Which arguments? A function is self contained, so it only has access to the variables that are passed to&nbsp;it.</p>
<p>Should we calculate all the lengths in one go, or calculate the length of one specified&nbsp;element?</p>
<h3>Solver&#8212;general</h3>
<p>A reminder of the global system being solved (<span class="math">\(\mathbf{u}\)</span> is the&nbsp;unknown):
</p>
<div class="math">\begin{align}
 [K]\{u\} = \{F\}
\end{align}</div>
<p>
This is a simultaneous system of equations. Each element must&nbsp;satisfy:
</p>
<div class="math">\begin{align}
 [K^e]\{u^e\} = \{F^e\}
\end{align}</div>
<p>The element solution vector (<span class="math">\(\mathbf{u}^e\)</span>) defines the displacement of the element. It has 4 components, or <strong>degrees-of-freedom</strong>: <span class="math">\(u_1, v_1, u_2, v_2\)</span>. We can choose to order&nbsp;these:
 </p>
<div class="math">\begin{align}
  \mathbf{u}^e = 
  \begin{Bmatrix}
    u_1\\v_1\\u_2\\v_2
  \end{Bmatrix}
  \text{ or }
  \begin{Bmatrix}
    u_1\\u_2\\v_1\\v_2
  \end{Bmatrix}
 \end{align}</div>
<p><img alt="Degrees-of-freedom on a truss" src="/images/elementdisp.png"></p>
<p>The global solution vector is similar. We should choose and stick to one <span class="caps">DOF</span> ordering&nbsp;system.</p>
<h3>Solver&#8212;element matrices, local&nbsp;coordinates</h3>
<p>We know the stiffness of a beam, <span class="math">\(k\)</span>, in its longitudinal direction is given&nbsp;by:</p>
<div class="math">\begin{align}
 k = \frac{EA}{L}
\end{align}</div>
<p><img alt="Degrees-of-freedom in the local coordinate system" src="/images/elementlocal.png"></p>
<p>This corresponds to the direction <span class="math">\(x'\)</span> in the local coordinate system <span class="math">\((x',y')\)</span>, with associated displacements <span class="math">\((u',v')\)</span>, <em>i.e.</em> the&nbsp;system:
</p>
<div class="math">\begin{align}
 \begin{bmatrix}
  k &amp; 0 &amp; -k &amp; 0 \\
  0 &amp; 0 &amp;  0 &amp; 0 \\
 -k &amp; 0 &amp;  k &amp; 0 \\
  0 &amp; 0 &amp;  0 &amp; 0
 \end{bmatrix}
 \begin{Bmatrix}
  u'_1\\v'_1\\u'_2\\v'_2
 \end{Bmatrix}
 = 
 \begin{Bmatrix}
  F^{x'}_{1}\\F^{y'}_{1}\\F^{x'}_{2}\\F^{y'}_{2}
 \end{Bmatrix}
\end{align}</div>
<h3>Solver&#8212;local element matrices in <span class="caps">MATLAB</span></h3>
<p>We know how to get <span class="math">\(E,A,\text{ and }L\)</span> from the input data for a given element. We know how to create empty matrices, and how to get data into&nbsp;them.</p>
<p>So, creating the element stiffness matrices in the element coordinate system (<span class="math">\(\mathbf{K}'^e\)</span>) should be&nbsp;simple!</p>
<p>Once we know how to calculate a single element, we can wrap the code in a loop to calculate for all the&nbsp;elements:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">element</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">element_nodes</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c">% total number of elements is given by the</span>
                                    <span class="c">%   number of rows in the element nodes list</span>
    <span class="n">E</span> <span class="p">=</span> <span class="n">element_modulus</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>     
    <span class="n">A</span> <span class="p">=</span> <span class="c">...                           % collect all the parameters we need to</span>
    <span class="c">...                               %   calculate k</span>

    <span class="n">k</span> <span class="p">=</span> <span class="c">...                           % calculate k</span>

    <span class="n">Ke_local</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>            <span class="c">% prepare an empty matrix for the local element</span>
                                    <span class="c">%   stiffness matrix</span>

    <span class="n">Ke_local</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="c">...               % put the relevant terms into the matrix!</span>
<span class="k">end</span>
</pre></div>
</td></tr></table>

<h3>Solver&#8212;element matrices in global&nbsp;coordinates</h3>
<p>Each node will have a displacement. So far, we&#8217;ve described that displacement in a local (element) coordinate system <span class="math">\((x',y')\)</span>. Where a node is shared by two elements, which element&#8217;s coordinate system should be&nbsp;used?</p>
<p>All the displacements shoud be expressed in the <strong>global coordinate system</strong>, <span class="math">\((x,y)\)</span>.</p>
<p>The global and local coordinate systems can be transformed using the transformation matrix, <span class="math">\(\mathbf{T^{\ast}}\)</span> (in&nbsp;2D):</p>
<div class="math">\begin{align}
 \begin{Bmatrix}
  u' \\ v'
 \end{Bmatrix}
 &amp;=
 \begin{bmatrix}
  \cos\theta &amp; \sin\theta \\
 -\sin\theta &amp; \cos\theta
 \end{bmatrix}
 \begin{Bmatrix}
  u \\ v
 \end{Bmatrix}
 &amp; 
 \mathbf{u}' &amp;= \mathbf{T^{\ast}}\mathbf{u}
\end{align}</div>
<p>
Which allows us to perform the transform of the element local stiffness&nbsp;matrix:
</p>
<div class="math">\begin{align}
 \mathbf{K}^e = \mathbf{T}^T \mathbf{K}'^{e} \mathbf{T}
\end{align}</div>
<p>where in the case of a 2 node&nbsp;element,</p>
<div class="math">\begin{align}
\mathbf{T} = \begin{bmatrix}\mathbf{T^{\ast}} &amp; 0 \\ 0 &amp; \mathbf{T^{\ast}}\end{bmatrix}
\end{align}</div>
<h3>Element transform in <span class="caps">MATLAB</span></h3>
<p>We need to know the angle, <span class="math">\(\theta\)</span> of the element. We could write a function, similar to our <code>calculate_length</code> function:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>[element_angle] <span class="p">=</span><span class="w"> </span><span class="nf">calculate_angle</span><span class="p">(</span>arguments<span class="p">)</span><span class="w"></span>
<span class="c">% A function to calculate the angle of the elements</span>
<span class="c">% Think about which variables need to be passed in to calculate</span>
<span class="c">%   the angles</span>
<span class="c">% MATLAB&#39;s atan2 function might be useful here...</span>
<span class="k">return</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>We could also do with a function to give us a transform matrix for any angle <code>theta</code>:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>[T] <span class="p">=</span><span class="w"> </span><span class="nf">transformmatrix</span><span class="p">(</span>theta<span class="p">)</span><span class="w"></span>
<span class="c">% A function to calculate the transform matrix</span>
<span class="n">T</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>              <span class="c">% create an empty matrix</span>
<span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="nb">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>         <span class="c">% start filling it in...</span>
<span class="c">...</span>
<span class="k">return</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>Then, in the element loop, we can add the following&nbsp;lines:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">theta</span> <span class="p">=</span> <span class="n">element_angle</span><span class="p">(</span><span class="n">element</span><span class="p">);</span> <span class="c">% get the angle of the current element</span>
<span class="n">T</span> <span class="p">=</span> <span class="n">transformmatrix</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>     <span class="c">% calculate the transform matrix</span>
<span class="n">Ke</span> <span class="p">=</span> <span class="n">T</span><span class="o">&#39;</span> <span class="o">*</span> <span class="n">Ke_local</span> <span class="o">*</span> <span class="n">T</span><span class="p">;</span>         <span class="c">% transform the local element stiffness matrix</span>
</pre></div>
</td></tr></table>

<h3>The global stiffness&nbsp;matrix</h3>
<p>Now we have <span class="math">\(\mathbf{K}^e\)</span> for all the elements, we can construct the global stiffness matrix. This is a process called <strong>assembly</strong> or <strong>scattering</strong>.
Each of our elements had 4 <span class="caps">DOF</span>, (2 displacement components, <span class="math">\(u\)</span> and <span class="math">\(v\)</span>, at each end of the element), and hence a <span class="math">\(4\times4\)</span> <span class="math">\(\mathbf{K}^e\)</span>. We can calculate the size of <span class="math">\(\mathbf{K}\)</span> using the total number of degrees of&nbsp;freedom:</p>
<div class="highlight"><pre><span></span><span class="n">globaldof</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">nodal_coordinates</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">size</span><span class="p">(</span><span class="n">nodal_coordinates</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</pre></div>


<p>Each element&#8217;s stiffness contribution to the global stiffness matrix must be added in at the appropriate&nbsp;position.</p>
<h3>Scattering</h3>
<p>Example: element 3 connects nodes 1 and 3 (<code>element_nodes(3,:)</code>):</p>
<p>Element stiffness&nbsp;matrix:
</p>
<div class="math">\begin{align*}
 \begin{array}{r}
  1, \mathbf{1}, x \\
  1, \mathbf{1}, y \\
  2, \mathbf{3}, x \\
  2, \mathbf{3}, y \\
 \end{array}
 \begin{bmatrix}
  k^{3}_{11} &amp; k^{3}_{12} &amp;  k^{3}_{13} &amp; k^{3}_{14} \\  
  k^{3}_{21} &amp; k^{3}_{22} &amp;  k^{3}_{23} &amp; k^{3}_{24} \\
  k^{3}_{31} &amp; k^{3}_{32} &amp;  k^{3}_{33} &amp; k^{3}_{34} \\
  k^{3}_{41} &amp; k^{3}_{42} &amp;  k^{3}_{43} &amp; k^{3}_{44}
 \end{bmatrix}
\end{align*}</div>
<p>
Global stiffness&nbsp;matrix:
</p>
<div class="math">\begin{align*}
 \rightarrow
 \begin{bmatrix}
  k^{3}_{11} &amp; k^{3}_{12} &amp; 0 &amp; 0 &amp;  k^{3}_{13} &amp; k^{3}_{14} \\  
  k^{3}_{21} &amp; k^{3}_{22} &amp; 0 &amp; 0 &amp;  k^{3}_{23} &amp; k^{3}_{24} \\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
  k^{3}_{31} &amp; k^{3}_{32} &amp; 0 &amp; 0 &amp;  k^{3}_{33} &amp; k^{3}_{34} \\
  k^{3}_{41} &amp; k^{3}_{42} &amp; 0 &amp; 0 &amp;  k^{3}_{43} &amp; k^{3}_{44}
 \end{bmatrix}
 \begin{array}{l}
  \mathbf{1}, x \\
  \mathbf{1}, y \\
  \mathbf{2}, x \\
  \mathbf{2}, y \\
  \mathbf{3}, x \\
  \mathbf{3}, y
 \end{array}
\end{align*}</div>
<p>(<span class="math">\(1\)</span>:local or element node numbers; <span class="math">\(\mathbf{1}\)</span>: global node&nbsp;numbers)</p>
<h3>The scattering process in <span class="caps">MATLAB</span></h3>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">K</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span> <span class="p">);</span>      <span class="c">% create an empty stiffness matrix of appropriate size</span>

<span class="k">for</span> <span class="n">element</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">size</span><span class="p">(</span><span class="n">element_nodes</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
    <span class="c">...            % calculate all the terms necessary to give:</span>
    <span class="n">Ke</span> <span class="p">=</span> <span class="c">...       %   element stiffness matrix</span>

    <span class="k">for</span> <span class="n">local_node_number_r</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span>      <span class="c">% loop through each node in the ROWS direction</span>
        <span class="c">% First we figure out which global node this refers to:</span>
        <span class="n">global_node_number_r</span> <span class="p">=</span> <span class="n">element_nodes</span><span class="p">(</span><span class="n">element</span><span class="p">,</span><span class="n">local_node_number_r</span><span class="p">);</span>

        <span class="c">% Then we figure out where in the stiffness matrix the terms are:</span>
        <span class="n">local_index_r</span>  <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span> <span class="n">local_node_number_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">];</span>
        <span class="n">global_index_r</span> <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">global_node_number_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">];</span>

        <span class="k">for</span> <span class="n">local_node_number_c</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span>  <span class="c">% loop through each node in the COLUMNS direction</span>
            <span class="c">% Follow the same process for the COLUMNS</span>
            <span class="n">global_node_number_c</span> <span class="p">=</span> <span class="n">element_nodes</span><span class="p">(</span><span class="n">element</span><span class="p">,</span><span class="n">local_node_number_c</span><span class="p">);</span>
            <span class="n">local_index_c</span>  <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span> <span class="n">local_node_number_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">];</span>
            <span class="n">global_index_c</span> <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">global_node_number_c</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">];</span>

            <span class="c">% Then, we can add the relevant terms to the global stiffness matrix, K</span>
            <span class="n">K</span><span class="p">(</span><span class="n">global_index_r</span><span class="p">,</span><span class="n">global_index_c</span><span class="p">)</span> <span class="p">=</span> <span class="n">K</span><span class="p">(</span><span class="n">global_index_r</span><span class="p">,</span><span class="n">global_index_c</span><span class="p">)</span> <span class="c">...</span>
                                            <span class="o">+</span> <span class="n">Ke</span><span class="p">(</span><span class="n">local_index_r</span><span class="p">,</span><span class="n">local_index_c</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</td></tr></table>

<h3>The force&nbsp;vector</h3>
<p>We have our stiffness matrix. We also need the force vector, <span class="math">\(F\)</span>.</p>
<p>Remember, when we input this, we input it in the&nbsp;form:
 </p>
<div class="math">\begin{align}
  \begin{bmatrix}
   F_{x}^{1} &amp; F_{y}^{1} \\
   F_{x}^{2} &amp; F_{y}^{2} \\
   F_{x}^{3} &amp; F_{y}^{3} 
  \end{bmatrix}
 \end{align}</div>
<p>but we really need it as a vector, with the same ordering scheme as the stiffness&nbsp;matrix:</p>
<div class="math">\begin{align}
  \begin{bmatrix}
   F_{x}^{1} \\ F_{y}^{1} \\
   F_{x}^{2} \\ F_{y}^{2} \\
   F_{x}^{3} \\ F_{y}^{3} 
  \end{bmatrix}
 \end{align}</div>
<p>We need to perform a similar scattering operation to form <span class="math">\(F\)</span>. We only need 1 loop, since there is only 1 column in the&nbsp;vector.</p>
<h3>Applying boundary&nbsp;conditions</h3>
<p>At the moment, the system is unconstrained: this means that there is no unique solution, and rigid body motion can occur. We need to input some boundary&nbsp;conditions:</p>
<div class="math">\begin{align}
   \begin{bmatrix}
    1 &amp; 1 \\
    0 &amp; 1 \\
    0 &amp; 0
   \end{bmatrix}
   \begin{array}{l}
    \text{node 1: constrained (1) in x and y directions} \\
    \text{node 2: sliding joint, constrained in y only} \\
    \text{node 3: free: not constrained at all}
   \end{array}
  \end{align}</div>
<p>where <span class="math">\(1\)</span> indicates that a degree of freedom is constrained to no&nbsp;displacement.</p>
<p>The boundary condition is applied by eliminating the row and column relevent to the degree of freedom in the system of&nbsp;equations.</p>
<h3>Applying boundary conditions in <span class="caps">MATLAB</span></h3>
<p>Removing rows and columns from the matrix will change their size, and we might lose track of which row/column corresponds to which displacement. Instead, we can achieve the same by replacing the rows and columns by the relevant bits of the identity&nbsp;matrix:</p>
<div class="math">\begin{align}
 \begin{bmatrix}
  k_{11} &amp; k_{12} &amp;  k_{13} &amp; k_{14} \\  
  k_{21} &amp; k_{22} &amp;  k_{23} &amp; k_{24} \\
  k_{31} &amp; k_{32} &amp;  k_{33} &amp; k_{34} \\
  k_{41} &amp; k_{42} &amp;  k_{43} &amp; k_{44}
 \end{bmatrix}
 \begin{Bmatrix}
  u_1 \\ v_1 \\ u_2 \\ v_2
 \end{Bmatrix}
 = 
 \begin{Bmatrix}
  F_{1}^{x} \\ F_{1}^{y} \\ F_{2}^{x} \\ F_{2}^{y}
 \end{Bmatrix}
\end{align}</div>
<p>Constraining <span class="math">\(v_1=0\)</span>, </p>
<div class="math">\begin{align}
 \begin{bmatrix}
  k_{11} &amp; 0 &amp;  k_{13} &amp; k_{14} \\  
  0      &amp; 1 &amp;  0      &amp; 0      \\
  k_{31} &amp; 0 &amp;  k_{33} &amp; k_{34} \\
  k_{41} &amp; 0 &amp;  k_{43} &amp; k_{44}
 \end{bmatrix}
 \begin{Bmatrix}
  u_1 \\ v_1 \\ u_2 \\ v_2
 \end{Bmatrix}
 = 
 \begin{Bmatrix}
  F_{1}^{x} \\ 0 \\ F_{2}^{x} \\ F_{2}^{y}
 \end{Bmatrix}
\end{align}</div>
<p>Applying this process in <span class="caps">MATLAB</span> should be&nbsp;easy:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% in a loop iterating over the boundary conditions...</span>

<span class="k">if</span> <span class="n">boundary_condition</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>          <span class="c">% check if we need to constrain displacement</span>

    <span class="c">% STIFFNESS MATRIX</span>
    <span class="n">K</span><span class="p">(</span><span class="nb">i</span><span class="p">,:)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>                        <span class="c">% set the whole row to zero</span>
    <span class="n">K</span><span class="p">(:,</span><span class="nb">i</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>                        <span class="c">% set the whole column to zero</span>

    <span class="n">K</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="nb">i</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>                        <span class="c">% set the term on the diagonal to 1</span>

    <span class="c">% FORCE VECTOR</span>
    <span class="n">F</span><span class="p">(</span><span class="nb">i</span><span class="p">)</span>   <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>                        <span class="c">% set the term in the force vector to zero</span>

<span class="k">end</span>
</pre></div>
</td></tr></table>

<h3>Solving</h3>
<p>Now all our hard work is done. The system is set up, and all that remains is for <span class="caps">MATLAB</span> to solve it for the unknowns (in our case, displacements). We saw how to do this using the <span class="caps">MATLAB</span> <code>backslash</code> operator&nbsp;earlier:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">% Solve the system [K]{u} = {F} for unknown {u}</span>
<span class="n">u</span> <span class="p">=</span> <span class="n">K</span><span class="o">\</span><span class="n">F</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<h3>Post&nbsp;processor</h3>
<p>Once the displacements <span class="math">\(\mathbf{u}\)</span> are determined, calculating the strain shouldn&#8217;t be difficult. Strain is given&nbsp;by:</p>
<div class="math">\begin{align}
    \varepsilon_{x'} = \frac{\partial u'}{\partial x'} = \frac{\Delta L}{L}
  \end{align}</div>
<p>where <span class="math">\(\Delta L\)</span> is the change in length of the element. The new length of the element (after displacement) is given by the length calculated using the original coordinates, <span class="math">\(\mathbf{x}\)</span>, plus the displacements <span class="math">\(\mathbf{u}\)</span>. In fact, we could probably reuse our function <code>calculate_length()</code>.</p>
<p>Knowing the strains, stresses are then trivial to&nbsp;calculate.</p>
<h3>Conclusions</h3>
<p>Not all the required code has been given here, but there is enough to construct a simple beam element finite element code, in 1-, 2- or 3-D as required. Using information from earlier in the <span class="caps">FE</span> course, it should be possible to add in moment sustaining&nbsp;elements.</p>
<ul>
<li>The easiest way to get started in <span class="caps">MATLAB</span> is just to play with&nbsp;it</li>
<li>Begin by using it as a calculator - a single operation at a time, rather than as a full programming&nbsp;language</li>
<li><span class="caps">MATLAB</span> &#8216;thinks&#8217; in matrices: once the matrices are defined, <span class="caps">MATLAB</span> understands what it means  to e.g. multiply&nbsp;matrices</li>
<li>Even when using it as a programming language, it&#8217;s easy to go back to the command line and try typing a line in to see what it&nbsp;does</li>
</ul>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="//amit.visrolia.net/tag/matlab.html">matlab</a>
      <a href="//amit.visrolia.net/tag/code.html">code</a>
      <a href="//amit.visrolia.net/tag/teaching.html">teaching</a>
      <a href="//amit.visrolia.net/tag/bath.html">bath</a>
    </p>
  </div>



</article>

    <footer>
<p>&copy; Amit Visrolia 2016</p>
    </footer>
  </main>


<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Amit's notes ",
  "url" : "//amit.visrolia.net",
  "image": "",
  "description": "Amit's notes, links, and pictures"
}
</script>
</body>
</html>